1
00:00:00,000 --> 00:00:03,000
译ExpressionChangedAfterItHasBeenCheckedError.

2
00:00:03,000 --> 00:00:04,775
译You'll encounter this error if your

3
00:00:04,775 --> 00:00:06,838
code changes a value after change detection

4
00:00:06,838 --> 00:00:08,805
has been run and the view has been built.

5
00:00:08,805 --> 00:00:10,772
You'll only see this error in development

6
00:00:10,772 --> 00:00:12,499
译because Angular runs an additional

7
00:00:12,499 --> 00:00:14,322
change detection check to catch errors

8
00:00:14,322 --> 00:00:16,097
like 译this that can cause erratic UI

9
00:00:16,097 --> 00:00:17,872
behavior. The extra check ensures the

10
00:00:17,872 --> 00:00:19,839
app is stable and that 译all data updates

11
00:00:19,839 --> 00:00:21,710
have been reflected in the views. There

12
00:00:21,710 --> 00:00:23,581
are a variety of reasons the view might

13
00:00:23,581 --> 00:00:25,500
译be left in an inconsistent state, such

14
00:00:25,500 --> 00:00:27,227
as code that updates the view during

15
00:00:27,227 --> 00:00:29,002
the AfterViewInit 译lifecycle hook or

16
00:00:29,002 --> 00:00:30,777
when change detection triggers itself

17
00:00:30,777 --> 00:00:32,648
in an infinite loop, like a method that

18
00:00:32,648 --> 00:00:34,471
译returns a different value each time,

19
00:00:34,471 --> 00:00:36,246
or a child component that changes the

20
00:00:36,246 --> 00:00:37,349
bindings on its parent.

21
00:00:38,212 --> 00:00:39,994
译Let's start by looking at a simple

22
00:00:39,994 --> 00:00:41,281
reproduction and solution.

23
00:00:41,331 --> 00:00:43,350
译Then, we'll take a more detailed 译look

24
00:00:43,350 --> 00:00:45,467
at Angular's change detection to understand

25
00:00:45,467 --> 00:00:47,732
why this error happens and why it's important.

26
00:00:47,732 --> 00:00:49,504
译Here in the app component template

27
00:00:49,504 --> 00:00:51,326
we're using the ngIf directive with a

28
00:00:51,326 --> 00:00:53,246
loading boolean. 译In the model, or our

29
00:00:53,246 --> 00:00:55,363
component type script, we give it a default

30
00:00:55,363 --> 00:00:57,628
value of true. Then, using 译the AfterViewInit

31
00:00:57,628 --> 00:00:59,647
lifecycle hook we flip the value to false

32
00:00:59,647 --> 00:01:01,469
when it's done loading. 译But when we

33
00:01:01,469 --> 00:01:04,669
run this code we see ExpressionChangedAfterItHasBeenCheckedError:

34
00:01:04,669 --> 00:01:06,589
译Previous value: false, Current value:

35
00:01:06,589 --> 00:01:08,558
true. Now in a more complex app it might

36
00:01:08,558 --> 00:01:10,626
not be 译clear where this error originates

37
00:01:10,626 --> 00:01:12,398
from, but you can always assume that

38
00:01:12,398 --> 00:01:14,318
it has 译something to do with a binding

39
00:01:14,318 --> 00:01:16,386
in the template. In the stack trace you'll

40
00:01:16,386 --> 00:01:18,306
find a link to the 译source map for the

41
00:01:18,306 --> 00:01:20,275
component template that caused the error

42
00:01:20,275 --> 00:01:22,146
and it takes us directly 译to the line

43
00:01:22,146 --> 00:01:23,918
of code that caused the issue, which

44
00:01:23,918 --> 00:01:26,035
is our ngIf binding to the loading boolean.

45
00:01:26,035 --> 00:01:27,857
译What the error is trying to tell us

46
00:01:27,857 --> 00:01:29,679
is that the loading value has changed

47
00:01:29,679 --> 00:01:31,550
after the change 译detection cycle has

48
00:01:31,550 --> 00:01:33,322
completed, but what exactly is wrong

49
00:01:33,322 --> 00:01:35,242
with our code in this case? 译The short

50
00:01:35,242 --> 00:01:37,014
answer is that we're using the wrong

51
00:01:37,014 --> 00:01:38,836
lifecycle hook. 译If we move our code

52
00:01:38,836 --> 00:01:40,707
from AfterViewInit to OnInit the error

53
00:01:40,707 --> 00:01:42,824
goes 译away and everything works perfectly.

54
00:01:42,824 --> 00:01:44,596
In other words, if you find yourself

55
00:01:44,596 --> 00:01:46,664
updating 译values in AfterViewInit there's

56
00:01:46,664 --> 00:01:48,436
a good chance that a simple refactor

57
00:01:48,436 --> 00:01:50,405
to OnInit or the 译component constructor

58
00:01:50,405 --> 00:01:52,325
will fix the issue. Okay, at this point

59
00:01:52,325 --> 00:01:54,147
we know we used the wrong 译lifecycle

60
00:01:54,147 --> 00:01:56,018
hook and we can fix it by refactoring,

61
00:01:56,018 --> 00:01:57,840
but to really understand why let's do

62
00:01:57,840 --> 00:01:59,809
a quick 译review of how change detection

63
00:01:59,809 --> 00:02:01,581
works in Angular. The goal of change

64
00:02:01,581 --> 00:02:03,452
detection is to 译keep the model, your

65
00:02:03,452 --> 00:02:05,569
typescript code, in sync with the template,

66
00:02:05,569 --> 00:02:07,440
your html. 译And it does so by looking

67
00:02:07,440 --> 00:02:09,311
for data changes in the component tree

68
00:02:09,311 --> 00:02:11,133
from top to bottom. 译First it checks

69
00:02:11,133 --> 00:02:13,102
the parent, then the first child, second

70
00:02:13,102 --> 00:02:15,317
child and so on, but if we update a 译binding

71
00:02:15,317 --> 00:02:17,237
on the parent after it has already been

72
00:02:17,237 --> 00:02:19,059
checked Angular will throw the error.

73
00:02:19,059 --> 00:02:20,979
译Now what we have here is a simplified

74
00:02:20,979 --> 00:02:22,801
breakdown of Angular's life cycle, or

75
00:02:22,801 --> 00:02:24,770
the steps 译it performs when a component

76
00:02:24,770 --> 00:02:26,641
is first initialized. First it updates

77
00:02:26,641 --> 00:02:28,512
the bindings like 译the ngIf directive

78
00:02:28,512 --> 00:02:30,481
in the template. Then it runs the OnInit

79
00:02:30,481 --> 00:02:32,401
lifecycle 译hook, updates the DOM, then

80
00:02:32,401 --> 00:02:34,666
runs change detection for the child component.

81
00:02:34,666 --> 00:02:36,881
译Notice how the final step is AfterViewInit,

82
00:02:36,881 --> 00:02:38,900
and more importantly that it 译runs after

83
00:02:38,900 --> 00:02:40,672
change detection. Basically any code

84
00:02:40,672 --> 00:02:42,543
that runs here 译should not attempt to

85
00:02:42,543 --> 00:02:44,365
update the view and that was the root

86
00:02:44,365 --> 00:02:46,433
of the problem in this case. 译Refactoring

87
00:02:46,433 --> 00:02:48,452
to OnInit works great for initial values,

88
00:02:48,452 --> 00:02:50,372
but if that doesn't fix the issue there

89
00:02:50,372 --> 00:02:52,686
译are a few other ways you may have encountered

90
00:02:52,686 --> 00:02:54,557
this error, along with additional ways

91
00:02:54,557 --> 00:02:56,576
to fix it. 译In the component here, we're

92
00:02:56,576 --> 00:02:58,496
using ViewChild to grab an element from

93
00:02:58,496 --> 00:03:00,268
the DOM, but this 译element won't be

94
00:03:00,268 --> 00:03:02,385
available until the AfterViewInit lifecycle

95
00:03:02,385 --> 00:03:04,256
hook is called. 译But what if we can't

96
00:03:04,256 --> 00:03:06,176
update the state of the component until

97
00:03:06,176 --> 00:03:08,047
after we 译have the ViewChild element?

98
00:03:08,047 --> 00:03:09,918
If we can't refactor to ngOnInit, 译we

99
00:03:09,918 --> 00:03:12,035
have a couple of other options. An approach

100
00:03:12,035 --> 00:03:14,152
you'll often see on StackOverflow 译answers

101
00:03:14,152 --> 00:03:16,121
is to make the update asynchronous. When

102
00:03:16,121 --> 00:03:18,238
we make the update async, it'll be 译picked

103
00:03:18,238 --> 00:03:20,060
up on the next change detection check

104
00:03:20,060 --> 00:03:21,882
and prevent the error from occurring.

105
00:03:21,882 --> 00:03:23,901
译We can make it asynchronous by wrapping

106
00:03:23,901 --> 00:03:25,920
it in a set timeout with a delay of zero.

107
00:03:25,920 --> 00:03:27,692
That'll put 译the update in the next

108
00:03:27,692 --> 00:03:29,661
macro task queue of the Javascript event

109
00:03:29,661 --> 00:03:31,729
loop. Alternatively we can use 译a promise

110
00:03:31,729 --> 00:03:33,649
that resolves immediately, then run the

111
00:03:33,649 --> 00:03:35,520
update in its callback. This code will

112
00:03:35,520 --> 00:03:37,588
achieve the 译same result, the only subtle

113
00:03:37,588 --> 00:03:39,508
difference is that it runs on the micro

114
00:03:39,508 --> 00:03:41,576
task queue before the end of 译the current

115
00:03:41,576 --> 00:03:43,447
iteration in the browser's event loop.

116
00:03:43,447 --> 00:03:45,515
Making the update asynchronous can 译work,

117
00:03:45,515 --> 00:03:47,337
however it's very implicit and should

118
00:03:47,337 --> 00:03:49,159
really only be used as a last resort.

119
00:03:49,159 --> 00:03:51,030
译It's not clear why we make this code

120
00:03:51,030 --> 00:03:52,901
asynchronous unless you understand the

121
00:03:52,901 --> 00:03:54,723
nuances of Angular 译change detection

122
00:03:54,723 --> 00:03:56,545
and the browser's event loop. Luckily

123
00:03:56,545 --> 00:03:58,416
Angular provides us with a more direct

124
00:03:58,416 --> 00:04:00,188
译and explicit way to trigger change

125
00:04:00,188 --> 00:04:02,010
detection. We can manually trigger it

126
00:04:02,010 --> 00:04:03,881
by injecting the change 译detector ref

127
00:04:03,881 --> 00:04:05,653
in the constructor of the component.

128
00:04:05,653 --> 00:04:07,672
We can then use it to manually run change

129
00:04:07,672 --> 00:04:09,691
译detection by calling the detect changes

130
00:04:09,691 --> 00:04:11,611
method. This will tell Angular to check

131
00:04:11,611 --> 00:04:13,433
the view and 译its children, in which

132
00:04:13,433 --> 00:04:15,205
case it will notice that our loading

133
00:04:15,205 --> 00:04:17,273
state has changed, giving 译us yet another

134
00:04:17,273 --> 00:04:19,292
way to address the error. Now an entirely

135
00:04:19,292 --> 00:04:21,261
different way you might encounter 译this

136
00:04:21,261 --> 00:04:23,230
error is when you have a method, usually

137
00:04:23,230 --> 00:04:25,347
a getter, that doesn't return a predictable

138
00:04:25,347 --> 00:04:27,119
value, 译which can cause an infinite

139
00:04:27,119 --> 00:04:29,039
change detection loop. Take for example

140
00:04:29,039 --> 00:04:31,156
this getter in our 译component that returns

141
00:04:31,156 --> 00:04:33,027
a random number. If we try to use this

142
00:04:33,027 --> 00:04:34,849
value in the 译template, Angular will

143
00:04:34,849 --> 00:04:36,621
get a different value each time it's

144
00:04:36,621 --> 00:04:38,393
checked. 译The solution in this case

145
00:04:38,393 --> 00:04:40,412
is to make the method return a consistent

146
00:04:40,412 --> 00:04:42,578
译value based on the state of the component.

147
00:04:42,578 --> 00:04:44,547
In other words getters should be derived

148
00:04:44,547 --> 00:04:46,467
译directly from the component state and

149
00:04:46,467 --> 00:04:48,436
not values that change constantly 译like

150
00:04:48,436 --> 00:04:50,356
timestamps or random numbers. Now let's

151
00:04:50,356 --> 00:04:52,227
take a look at one more example, where

152
00:04:52,227 --> 00:04:54,344
译we have both a parent and child component

153
00:04:54,344 --> 00:04:56,166
at play. The app component the parent

154
00:04:56,166 --> 00:04:58,037
contains the 译loading state just like

155
00:04:58,037 --> 00:04:59,859
our previous examples, but instead of

156
00:04:59,859 --> 00:05:01,631
running the update from the 译parent

157
00:05:01,631 --> 00:05:03,403
component, we'll make it happen from

158
00:05:03,403 --> 00:05:05,274
a child component with a custom event.

159
00:05:05,274 --> 00:05:07,293
译In the item component, the child, we're

160
00:05:07,293 --> 00:05:09,115
using the @Output decorator to create

161
00:05:09,115 --> 00:05:10,887
译a custom event along with an event

162
00:05:10,887 --> 00:05:12,758
emitter. Then during ngOnInit we'll go

163
00:05:12,758 --> 00:05:14,678
ahead and 译emit the event with a value

164
00:05:14,678 --> 00:05:16,598
of true. Then back in the app component

165
00:05:16,598 --> 00:05:18,420
template we'll 译go ahead and declare

166
00:05:18,420 --> 00:05:20,389
the item component. When it fires, we'll

167
00:05:20,389 --> 00:05:22,211
set 译the loading value to false. The

168
00:05:22,211 --> 00:05:24,131
end result is a situation where we have

169
00:05:24,131 --> 00:05:26,051
a 译child component updating the parent

170
00:05:26,051 --> 00:05:27,922
after change detection has already run

171
00:05:27,922 --> 00:05:29,694
on the parent, 译and once again that

172
00:05:29,694 --> 00:05:31,663
produces the error. A potential solution

173
00:05:31,663 --> 00:05:33,780
in this case would be to 译move the loading

174
00:05:33,780 --> 00:05:35,602
state into the child component and if

175
00:05:35,602 --> 00:05:37,473
that's not possible you might consider

176
00:05:37,473 --> 00:05:39,393
译moving this state to a shared service

177
00:05:39,393 --> 00:05:41,165
where it can be injected in multiple

178
00:05:41,165 --> 00:05:41,707
components.

179
00:05:49,332 --> 00:05:51,519
译Let's finish up by doing a quick recap.

180
00:05:51,519 --> 00:05:54,026
The ExpressionChangedAfterItHasBeenCheckedError

181
00:05:54,026 --> 00:05:56,159
译occurs because a value in the template

182
00:05:56,159 --> 00:05:58,239
has been updated after change detection

183
00:05:58,239 --> 00:06:00,426
has finished. 译Debug it by first finding

184
00:06:00,426 --> 00:06:02,506
the template in the stack trace. 译From

185
00:06:02,506 --> 00:06:04,853
there you can analyze your code to determine

186
00:06:04,853 --> 00:06:06,773
where the value is being updated and

187
00:06:06,773 --> 00:06:08,906
use one of 译the methods covered in this

188
00:06:08,906 --> 00:06:11,039
video to address it, such as refactoring

189
00:06:11,039 --> 00:06:13,012
to the OnInit lifecycle 译hook, using

190
00:06:13,012 --> 00:06:14,932
change detector ref manually, making

191
00:06:14,932 --> 00:06:16,905
getters item potent, or making 译your

192
00:06:16,905 --> 00:06:18,878
updates async as a last resort. Refer

193
00:06:18,878 --> 00:06:21,278
to the Angular documentation 译for additional

194
00:06:21,278 --> 00:06:22,398
details and examples.
